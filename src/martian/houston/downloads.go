//
// Copyright (c) 2015 10X Genomics, Inc. All rights reserved.
//
// Houston download manager.
//

package main

import (
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"martian/core"
	"net/http"
	"os"
	"os/exec"
	"path"
	"regexp"
	"strings"
	"time"

	"github.com/dustin/go-humanize"
)

type DownloadSource interface {
	Enumerate() []Downloadable
}

type Downloadable interface {
	Size() uint64
	Key() string
	Modified() time.Time
	Download(dstPath string)
	Ticket() string
}

type Download struct {
	size   uint64
	year   string
	month  string
	day    string
	user   string
	domain string
	uid    string
	fname  string
	fbase  string
	ftype  string
	fdir   string
	path   string
}

func NewDownload(filesPath string, size uint64, year string, month string,
	day string, user string, domain string, uid string, fname string) *Download {
	self := &Download{}
	self.size = size
	self.year = year
	self.month = month
	self.day = day
	self.user = user
	self.domain = domain
	self.uid = uid
	self.fname = fname
	self.fbase = strings.Split(path.Base(fname), ".")[0]
	self.ftype = path.Ext(fname)
	self.fdir = fmt.Sprintf("%s%s", uid, self.ftype)
	self.path = path.Join(filesPath, fmt.Sprintf("%s@%s", domain, user),
		fmt.Sprintf("%s-%s-%s-%s", year, month, day, uid), self.fbase)
	return self
}

type DownloadManager struct {
	sources             []DownloadSource
	downloadPath        string
	downloadIntervalMin int
	downloadMaxMB       uint64
	filesPath           string
	keyRE               *regexp.Regexp
	sman                *SubmissionManager
}

func NewDownloadManager(downloadPath string, downloadIntervalMin,
	downloadMaxMB int, filesPath string, sman *SubmissionManager) *DownloadManager {
	self := &DownloadManager{}
	self.sources = []DownloadSource{}
	self.downloadPath = downloadPath
	self.downloadIntervalMin = downloadIntervalMin
	self.downloadMaxMB = uint64(downloadMaxMB * 1000 * 1000)
	self.filesPath = filesPath
	self.sman = sman
	self.keyRE = regexp.MustCompile("^(\\d{4})-(\\d{2})-(\\d{2})-(.*)@(.*\\.[^-]+)-([A-Z0-9]+)-(.*)$")
	return self
}

func (self *DownloadManager) AddDownloadSource(source DownloadSource) {
	self.sources = append(self.sources, source)
}

// Gets a download object and destination path for a downloadable.
func (self *DownloadManager) newDownload(
	downloadable Downloadable) (*Download, string) {
	size := downloadable.Size()
	key := downloadable.Key()

	// Enforce object key string formatting (as generated by miramar)
	subs := self.keyRE.FindStringSubmatch(key)
	if len(subs) != 8 {
		core.LogInfo("dwnload", "Failed to parse key: %s", key)
		return nil, ""
	}

	// Create download object
	d := NewDownload(self.filesPath, size, subs[1], subs[2], subs[3], subs[4], subs[5], subs[6], subs[7])

	// Skip if permanent path already exists
	if _, err := os.Stat(d.path); err == nil {
		//core.LogInfo("download", "    Already in permanent storage, skipping")
		return nil, ""
	}

	core.LogInfo("dwnload", "Processing %s", key)

	// Enforce max download size
	if size > self.downloadMaxMB {
		core.LogInfo("dwnload", "    Too large %s", humanize.Bytes(size))
		return nil, ""
	}

	return d, path.Join(self.downloadPath, key)
}

// Untar a pipestance and set up the symlinks we need.
func extractPipestance(d *Download, dstPath string) error {
	// Create pipestance folder
	if err := os.MkdirAll(d.path, 0777); err != nil {
		core.LogError(err, "dwnload", "    Could not create directory: %s", d.path)
		return err
	}

	// Untar pipestance into folder
	cmd := exec.Command("tar", "xf", dstPath, "-C", d.path)
	if _, err := cmd.Output(); err != nil {
		core.LogError(err, "dwnload", "    Error while untaring pipestance")
		return err
	}

	// Delete downloaded tar file
	os.Remove(dstPath)

	// Build HEAD symlink to pipestance folder
	files, _ := ioutil.ReadDir(d.path)
	if len(files) != 1 {
		core.LogInfo("dwnload", "    Tar file did not contain a pipestance folder")
		return fmt.Errorf("Tar file did not contain a pipestance.")
	}
	os.Symlink(files[0].Name(), path.Join(d.path, "HEAD"))
	return nil
}

// Copy the information we need.
func extractPlaintext(d *Download, dstPath string) error {
	cmd := exec.Command("cp", dstPath, path.Join(d.path, d.fname))

	// Create permanent storage folder for this key
	if err := os.MkdirAll(d.path, 0777); err != nil {
		core.LogError(err, "dwnload", "    Could not create directory: %s", d.path)
		return err
	}

	// Execute handler command
	if _, err := cmd.Output(); err != nil {
		core.LogError(err, "dwnload", "    Error while running handler")

		// Remove the fsPath so this can be retried later
		os.RemoveAll(d.path)
		return err
	}
	return nil
}

func (self *DownloadManager) download() map[string][]string {
	ticketlessPipestances := make(map[string][]string)

	// Iterate over all registered sources
	for _, source := range self.sources {

		// Iterate over all downloadables enumerated by source
		downloadables := source.Enumerate()
		for _, downloadable := range downloadables {
			d, dstPath := self.newDownload(downloadable)
			if d == nil {
				continue
			}
			downloadable.Download(dstPath)

			// Read 512 bytes of downloaded file for MIME type detection
			fd, err := os.Open(dstPath)
			if _, err = fd.Seek(0, 0); err != nil {
				core.LogError(err, "dwnload", "    Failed to seek to beginning of downloaded file")
				continue
			}
			defer fd.Close()
			magic := make([]byte, 512)
			if _, err = fd.Read(magic); err != nil {
				if err != io.EOF {
					core.LogError(err, "dwnload", "    Failed to read downloaded file %s", dstPath)
					continue
				}
			}
			mimeType := http.DetectContentType(magic)

			// Handling of downloaded file depends on type
			if strings.HasPrefix(mimeType, "application/x-gzip") &&
				(strings.HasSuffix(d.fname, "debug.tgz") || strings.HasSuffix(d.fname, "mri.tgz")) {
				core.LogInfo("dwnload", "    Pipestance, untaring")
				if err := extractPipestance(d, dstPath); err != nil {
					continue
				}
				if downloadable.Ticket() == "" {
					email := fmt.Sprintf("%s@%s", d.user, d.domain)
					pipes, _ := ticketlessPipestances[email]
					ticketlessPipestances[email] = append(pipes, d.path)
				}
			} else {
				if strings.HasPrefix(mimeType, "text/plain") {
					core.LogInfo("dwnload", "    Text file, copying")
				} else {
					core.LogInfo("dwnload", "    Unknown file, copying")
				}
				if err := extractPlaintext(d, dstPath); err != nil {
					continue
				}
			}
			meta := SubmissionMetadata{
				Time:   downloadable.Modified(),
				Ticket: downloadable.Ticket(),
			}
			if bytes, err := json.Marshal(&meta); err != nil {
				if err := ioutil.WriteFile(path.Join(d.path, SubmissionMetadataFilename), bytes, 0444); err != nil {
					core.LogError(err, "dwnload", "Failed to write metadata.")
				}
			} else {
				core.LogError(err, "dwnload", "Failed to marshal metadata.")
			}

			// Success! Remove the temporary downloaded file
			os.Remove(dstPath)
		}
	}
	return ticketlessPipestances
}

func (self *DownloadManager) StartDownloadLoop() {
	go func() {
		for {
			ticketlessPipestances := self.download()
			self.sman.InventorySubmissions()
			self.GenerateTickets(ticketlessPipestances)
			time.Sleep(time.Minute * time.Duration(self.downloadIntervalMin))
		}
	}()
}

func (self *DownloadManager) GenerateTickets(emails map[string][]string) {
	for email, pipestances := range emails {
		core.LogInfo("dwnload", "Would generate a ticket for %d pipestances for %s.  Skipping until everything is debugged.",
			len(pipestances), email)
	}
}
